---
title: "TODOs"
author: "Peter Hickey"
date: "19 November 2014"
output: html_document
---

# Partioning a methylome

The steps to partitioning a single methylome are:

1. Read in the CpG 1-tuples data and create a `GenomicRanges::GRanges` object with `mcols` named `T` and `M` storing the total number of reads and number of methylated reads, respectively. This object must also contain the `seqlengths`, which are most easily stored as a complete `Seqinfo` object in the `seqinfo` slot.
2. Remove CpGs overlapping known SNPs.
3. Identify PMRs
    - Compute the $\alpha$ distribution for a single chromosome. If the $\alpha$ distribution is "bimodal or long-tailed with a significant fraction of $\alpha$ values larger or equal to 1", the `MethylSeekR` authors take this as evidence of PMRs and recommend that these by masked.
    - If required, mask the PMRs.
4. Identify UMRs and LMRs
    - Selection of parameters to control FDR. Requires CGIs.
    - Identification of UMRs and LMRs
5. Post-processing
    - Identify MMRs, really the 'rest of the methylome'.
    - Ensure this is a true partition, i.e., no overlapping regions.
    
Steps 1-4 are basically the job of `MethylSeekR`. Step 5, however, is specific to `methsim`.
    
# Implementation

## Option 1: The `MethlySeekR` way

Just follow the `MethylSeekR` vignette to achieve Steps 1-4. Step 5 is specific to `methsim`.

## Option 2: The `MethylationTuples` way

Use the convenience functions provided by `methsim` to work with existing `MethylationTuples::MethtPat` objects to achieve Steps 1-4. Step 5 is specific to `methsim`.

1. Steps 1-4 
    - Option A: Just use `MethylSeekR` from 1-4.
    - Option B: Provide some convenience functions to work with `MethPat` 
    objects.
      - Step 1 and 2: Use `MethylationTuples::readMethtuple` -> 
      `MethylationTuples::filterOutVariants` -> `as(MethPat, "MethylSeekRGR")` 
      __or__ `MethylationTuples::readMethtuple` -> 
      `as(MethPat, "MethylSeekRGR")` -> 
      `lapply(list_of_msrgr, MethylSeekR::removeSNPs)`.
      - Step 3: __UP TO HERE__

2. Step 5
    - General post-processing functions
    
__TODO__: Run a `MethylSeekRGR` object through the `MethylSeekR` pipeline and get to writing the "Step 5" functionality, i.e., `partitionMethylome`.

# Key functions and classes

- [x] `MethylSeekRGR
  - A S4 class to formalise the informal `GRanges`-based object used as input by `MethylSeekR`.
- [x] `as(MethPat, "MethylSeekRGR")`
- [ ] `partitionMethylome`, ``
  - A wrapper(s) around `MethylSeekR::plotAlphaDistributionOneChr`,  `MethylSeekR::segmentPMDs`, `MethylSeekR::segmentUMRsLMRs`.
  - Or just use these directly? (Will need to move `MethylSeekR` to `DEPENDS` rather than `IMPORTS`.)

# Test script

```{r}
library("BSgenome.Hsapiens.UCSC.hg18")
library(MethylSeekR)
seq_lengths <- seqlengths(Hsapiens)
x <- readMethylome(system.file("extdata", "Lister2009_imr90_hg18_chr22.tab", 
                               package = "MethylSeekR"), seq_lengths)
x <- MethPat(SimpleList(M = matrix(x$M, dimnames = list(NULL, "IMR90")), 
                        U = matrix(x$T - x$M, dimnames = list(NULL, "IMR90"))), 
             MTuples(GTuples(seqnames(x), tuples = as.matrix(start(x)), 
                             strand(x), seqinfo = seqinfo(x)),
                     MethInfo("CG"))
             )
y <- as(x, "MethylSeekRGR")[[1]]

snps <- readSNPTable(system.file("extdata", "SNVs_hg18_chr22.tab", 
                                 package="MethylSeekR"), 
                     seq_lengths)
```

# TODO for tomorrow (04/02/2015)

- [ ] Create a list of `methsim::MethylSeekRGR` objects for the EPISCOPE, Lister, Seisenberger and Ziller datasets.
- [ ] Process each with `MethylSeekR` to create a partitioned methylome for each sample.
