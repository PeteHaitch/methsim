---
title: "TODOs"
author: "Peter Hickey"
date: "19 November 2014"
output: html_document
---

# Package name

Consider alternative names for package and GitHub repo, e.g., `bsbs`, `bssim`. Should package name be `CamelCase`, `lowercase`, etc., e.g.:

- __`MethSim`__: Consistent with `GenomicTuples`, `MethylationTuples`, etc.
- __`methsim`__: Simpler to type.

# Partioning a methylome

The steps to partitioning a single methylome are:

1. Read in the CpG 1-tuples data and create a `GenomicRanges::GRanges` object with `mcols` named `T` and `M` storing the total number of reads and number of methylated reads, respectively. This object must also contain the `seqlengths`, which are most easily stored as a complete `Seqinfo` object in the `seqinfo` slot.
2. Remove CpGs overlapping known SNPs.
3. Identify PMRs
    - Compute the $\alpha$ distribution for a single chromosome. If the $\alpha$ distribution is "bimodal or long-tailed with a significant fraction of $\alpha$ values larger or equal to 1", the `MethylSeekR` authors take this as evidence of PMRs and recommend that these by masked.
    - If required, mask the PMRs.
4. Identify UMRs and LMRs
    - Selection of parameters to control FDR. Requires CGIs.
    - Identification of UMRs and LMRs
5. Post-processing
    - Identify MMRs, really the 'rest of the methylome'.
    - Ensure this is a true partition, i.e., no overlapping regions.
    
Steps 1-4 are basically the job of `MethylSeekR`. Step 5, however, is specific to `methsim`.
    
# Implementation

## Option 1: The `MethlySeekR` way

Just follow the `MethylSeekR` vignette to achieve Steps 1-4. Step 5 is specific to `methsim`.

## Option 2: The `MethylationTuples` way

Use the convenience functions provided by `methsim` to work with existing `MethylationTuples::MethtPat` objects to achieve Steps 1-4. Step 5 is specific to `methsim`.

1. Steps 1-4 
    - Option A: Just use `MethylSeekR` from 1-4.
    - Option B: Provide some convenience functions to work with `MethPat` 
    objects.
      - Step 1 and 2: Use `MethylationTuples::readMethtuple` -> 
      `MethylationTuples::filterOutVariants` -> `as(MethPat, "MethylSeekRGR")` 
      __or__ `MethylationTuples::readMethtuple` -> 
      `as(MethPat, "MethylSeekRGR")` -> 
      `lapply(list_of_msrgr, MethylSeekR::removeSNPs)`.
      - Step 3: Use `MethylSeekR::plotAlphaDistributionOneChr` and 
      `MethylSeekR::segmentPMDs`.
      - Step 4: Use `MethylSeekR::calculateFDRs` and 
      `MethylSeekR::segmentUMRsLMRs`.
2. Step 5
    - Use `methsim::partitionMethylome`
    
__TODO__: Run a `MethylSeekRGR` object through the `MethylSeekR` pipeline and get to writing the "Step 5" functionality, i.e., `partitionMethylome`.

# Key functions and classes

- [x] `MethylSeekRGR
  - A S4 class to formalise the informal `GRanges`-based object used as input by `MethylSeekR`.
- [x] `as(MethPat, "MethylSeekRGR")`
- [ ] `PartitionedMethylome`
- [x] `partitionMethylome`

# Example script

To be adapted for processing all methylomes.
```{r, eval = FALSE}
# TODO: Investigate "chr.sel" argument
library("BSgenome.Hsapiens.UCSC.hg18")
seq_lengths <- seqlengths(Hsapiens)
x <- readMethylome(system.file("extdata", "Lister2009_imr90_hg18_chr22.tab", 
                               package = "MethylSeekR"), seq_lengths)
x <- MethPat(SimpleList(M = matrix(as.integer(x$M), 
                                   dimnames = list(NULL, "IMR90")), 
                        U = matrix(as.integer(x$T - x$M), 
                                   dimnames = list(NULL, "IMR90"))), 
             MTuples(GTuples(seqnames(x), tuples = as.matrix(start(x)), 
                             strand(x), seqinfo = seqinfo(x)),
                     MethInfo("CG"))
             )
msrgr <- as(x, "MethylSeekRGR")[[1]]

# TODO: Use MethylationTuples::filterVariants
snps <- readSNPTable(system.file("extdata", "SNVs_hg18_chr22.tab", 
                                 package = "MethylSeekR"), 
                     seq_lengths)

msrgr <- removeSNPs(msrgr, snps)
# TODO: Save plot as PDF
plotAlphaDistributionOneChr(m = msrgr, chr.sel = "chr22", num.cores = 1)
# TODO: Save plot as PDF
pmrs <- segmentPMDs(m = msrgr, chr.sel = "chr22", seqLengths = seq_lengths, 
                    num.cores = 1)
plotAlphaDistributionOneChr(m = subsetByOverlaps(
  msrgr, pmrs[values(pmrs)$type == "notPMD"]), chr.sel = "chr22", num.cores = 1)
# plotPMDSegmentation(m = msrgr, segs = pmrs)

# TODO: Update with path to appropriate CGI definition
cgi_file <- "~/Downloads/model-based-cpg-islands-hg18.txt"
cgi <- read.table(cgi_file, header = TRUE, as.is = TRUE)
cgi <- sort(GRanges(cgi$chr, IRanges(cgi$start, cgi$end), seqinfo = seqinfo(msrgr)))
cgi <- trim(resize(cgi, 5000, fix = "center"))

# TODO: Save plot as PDF
# TODO: If sample has no PMRs then the "PMDs" argument should be omitted.
fdrs <- calculateFDRs(m = msrgr, CGIs = cgi, PMDs = pmrs, num.cores = 1)
fdr_cutoff <- 5 
methylation_cutoff <- 0.5
minimum_number_cpgs <- as.integer(
  names(fdrs$FDRs[as.character(methylation_cutoff), ]
        [fdrs$FDRs[as.character(methylation_cutoff), ] < fdr_cutoff])[1])

# TODO: Update "myGenomeSeq" parameter according to sample.
# TODO: Save plot as PDF
# TODO: If sample has no PMRs then the "PMDs" argument should be omitted.
umrs_lmrs <- segmentUMRsLMRs(m = msrgr, meth.cutoff = methylation_cutoff,
                             nCpG.cutoff = minimum_number_cpgs, PMDs = pmrs, 
                             num.cores = 1, myGenomeSeq = Hsapiens, 
                             seqLengths = seq_lengths)
# plotFinalSegmentation(m = m, segs = umrs_lmrs, PMDs = pmrs, 
#                       meth.cutoff = methylation_cutoff)

pm <- partitionMethylome(umrs_lmrs = umrs_lmrs, pmrs = pmrs)
```

## TODO

- [x] Create a list of `methsim::MethylSeekRGR` objects for the EPISCOPE, Lister, Seisenberger and Ziller datasets.
- [x] Process each with `MethylSeekR` to create a partitioned methylome for each sample.
- [ ] Write `estModelParams(pm, 1-tuples or methLevel(), 2-tuples or cometh, higher-order tuples)`. For each type of region it should return the distribution of beta-values, co-methylation and haplotype frequencies.
  - See `process\_\[one | two | three\]\_tuples()` functions shown below (noting that these are designed for processing multiple samples from a single dataset).
  - Should return `MethSimParams`, an S4 class with the necessary simulation parameters.
- [ ] Write `simulate(params, nsim, seed, ...)` to simulate a methylome with the given parameters.

```{r, eval = FALSE}
process_one_tuples <- function(dataset, seqlevels, min_cov) {
  
  if (missing(seqlevels)) {
    stop("Must supply 'seqlevels'.")
  }
  
  # Read in data
  methpat <- readRDS(paste0("../processed_data/", dataset, "/", dataset,
                            "_1_tuples_strand_collapsed.rds"))
  l_pm <- readRDS(paste0("rds/", dataset, "/PartitionedMethylome/", dataset, 
                       "_pm.rds"))
  
  # Compute beta-values and annotate by region type
  beta <- bplapply(names(l_pm), function(sn, methpat, l_pm, min_cov, 
                                         seqlevels) {
    pm <- l_pm[[sn]]
    # Only want data on sample 'sn'.
    methpat <- methpat[, sn]
    # Retain only the relevant seqlevels.
    methpat <- keepSeqlevels(methpat, seqlevels)
    # Apply MethylationTuples::methLevel()
    val <- funByPM(FUN = MethylationTuples::methLevel, pm = pm, 
                   methpat = methpat, min_cov = min_cov)
    # Add information not returned by methLevel()
    val[, sample := sn]
    setnames(val, c("beta", "type", "sample"))
    setkeyv(val, c("sample", "type", "beta"))
    val
    }, methpat = methpat, l_pm = l_pm, min_cov = min_cov, seqlevels = seqlevels)
  beta <- rbindlist(beta)
  # Tabulate frequency of each beta-value by sample and type.
  beta[, .N, by = list(sample, type, beta)]
}

process_two_tuples <- function(dataset, seqlevels, min_cov) {
  
  if (missing(seqlevels)) {
    stop("Must supply 'seqlevels'.")
  }
  
  # Read in data
  methpat <- readRDS(paste0("../processed_data/", dataset, "/", dataset,
                            "_2_tuples_strand_collapsed.rds"))
  l_pm <- readRDS(paste0("rds/", dataset, "/PartitionedMethylome/", dataset, 
                       "_pm.rds"))
  
  # Compute beta-values and annotate by region type
  lor <- bplapply(names(l_pm), function(sn, methpat, l_pm, min_cov, seqlevels,  
                                        method, offset) {
    pm <- l_pm[[sn]]
    # Only want data on sample 'sn'.
    methpat <- methpat[, sn]
    # Retain only the relevant seqlevels.
    methpat <- keepSeqlevels(methpat, seqlevels)
    # Apply MethylationTuples::cometh()
    funByPM(MethylationTuples::cometh, pm = pm, methpat = methpat, 
            min_cov = min_cov, method = method, offset = offset)
    }, methpat = methpat, l_pm = l_pm, min_cov = min_cov, seqlevels = seqlevels, 
    method = "lor", offset = 0.5)
  lor <- rbindlist(lor)
  # NOTE: This ignores strand.
  lor_reduced <- lor[, IPD := pos2 - pos1][
    , list(IPD, sample, type, statistic)][
      , .N, by = list(sample, IPD, type, statistic)]
  setorder(lor_reduced, sample, IPD, type, -N)
  lor_reduced
}

process_three_tuples <- function(dataset, seqlevels, min_cov) {
  
  if (missing(seqlevels)) {
    stop("Must supply 'seqlevels'.")
  }
  
  # Read in data
  methpat <- readRDS(paste0("../processed_data/", dataset, "/", dataset,
                            "_3_tuples_strand_collapsed.rds"))
  l_pm <- readRDS(paste0("rds/", dataset, "/PartitionedMethylome/", dataset, 
                       "_pm.rds"))
  
  # Estimate the relative frequencies of methylation patterns at m-tuples
  pattern_freqs <- bplapply(names(l_pm), function(sn, methpat, l_pm, min_cov, 
                                                  seqlevels) {
    pm <- l_pm[[sn]]
    # Only want data on sample 'sn'.
    methpat <- methpat[, sn]
    # Retain only the relevant seqlevels.
    methpat <- keepSeqlevels(methpat, seqlevels)
    # Apply MethylationTuples::patternFreqs()
    funByPM(MethylationTuples::patternFreqs, pm = pm, methpat = methpat, 
            min_cov = min_cov)
    }, methpat = methpat, l_pm = l_pm, min_cov = min_cov, seqlevels = seqlevels)
  pattern_freqs <- rbindlist(pattern_freqs)
  grp <- c("sample", "type", grep("^h[0-9]", colnames(pattern_freqs), 
                                  value = TRUE))
  pattern_freqs_reduced <- pattern_freqs[, .N, by = grp]
  setorder(pattern_freqs_reduced, sample, type, -N)
  pattern_freqs_reduced
}
```

# Simulating a "truth" and reads from it

Each sample needs an underlying "true" methylome ("truth") from which the reads are simulated. 

## Biological variability

In order of increasing biological variability in the truth:

1. Same truth.
2. Same partition and same region-specific parameters but an independent realisation of the process.
3. Same partition but different region-specific parameters.
4. Different partition with different parameters.

Technical replicates correspond to 1. Biological replicates fall somewhere between 2-3. I suspect that 4 doesn't allow for sufficient control over the process to be generally useful.

### DMRs

To add DMRs requires introducing (known) biological differences between experimental conditions. I think this is best done by altering the region-specific parameters of one experimental condition (i.e. 3).

## Priorities

### Technical

This functionality is required in order to simulate a single sample's worth of data (the bare minimum in order for this package to be useful):

1. Being able to simulate a single truth.
2. Being able to simulate reads from a single truth.
3. Being able to generate `MethPat` object(s) from a single set of simulated reads.

### Biological

These are questions to explore once I am able to simulate a single sample's worth of data (in order of simplicity):

1. Simulate multiple samples' worth of reads from a single truth to see the effect of sequencing variability.
2. Simulate multiple samples' worth of reads from a truths with the same partition but with different region-specific parameters.
3. Being able to simulate multiple truths.
