---
title: "TODOs"
author: "Peter Hickey"
date: "19 November 2014"
output: html_document
---

# Partioning a methylome

The steps to partitioning a single methylome are:

1. Read in the CpG 1-tuples data and create a `GenomicRanges::GRanges` object with `mcols` named `T` and `M` storing the total number of reads and number of methylated reads, respectively. This object must also contain the `seqlengths`, which are most easily stored as a complete `Seqinfo` object in the `seqinfo` slot.
2. Remove CpGs overlapping known SNPs.
3. Identify PMRs
    - Compute the $\alpha$ distribution for a single chromosome. If the $\alpha$ distribution is "bimodal or long-tailed with a significant fraction of $\alpha$ values larger or equal to 1", the `MethylSeekR` authors take this as evidence of PMRs and recommend that these by masked.
    - If required, mask the PMRs.
4. Identify UMRs and LMRs
    - Selection of parameters to control FDR. Requires CGIs.
    - Identification of UMRs and LMRs
5. Post-processing
    - Identify MMRs, really the 'rest of the methylome'.
    - Ensure this is a true partition, i.e., no overlapping regions.
    
Steps 1-4 are basically the job of `MethylSeekR`. Step 5, however, is specific to `methsim`.
    
# Implementation

## Option 1: The `MethlySeekR` way

Just follow the `MethylSeekR` vignette to achieve Steps 1-4. Step 5 is specific to `methsim`.

## Option 2: The `MethylationTuples` way

Use the convenience functions provided by `methsim` to work with existing `MethylationTuples::MethtPat` objects to achieve Steps 1-4. Step 5 is specific to `methsim`.

1. Steps 1-4 
    - Option A: Just use `MethylSeekR` from 1-4.
    - Option B: Provide some convenience functions to work with `MethPat` 
    objects.
      - Step 1 and 2: Use `MethylationTuples::readMethtuple` -> 
      `MethylationTuples::filterOutVariants` -> `as(MethPat, "MethylSeekRGR")` 
      __or__ `MethylationTuples::readMethtuple` -> 
      `as(MethPat, "MethylSeekRGR")` -> 
      `lapply(list_of_msrgr, MethylSeekR::removeSNPs)`.
      - Step 3: Use `MethylSeekR::plotAlphaDistributionOneChr` and 
      `MethylSeekR::segmentPMDs`.
      - Step 4: Use `MethylSeekR::calculateFDRs` and 
      `MethylSeekR::segmentUMRsLMRs`.
2. Step 5
    - Use `methsim::partitionMethylome`
    
__TODO__: Run a `MethylSeekRGR` object through the `MethylSeekR` pipeline and get to writing the "Step 5" functionality, i.e., `partitionMethylome`.

# Key functions and classes

- [x] `MethylSeekRGR
  - A S4 class to formalise the informal `GRanges`-based object used as input by `MethylSeekR`.
- [x] `as(MethPat, "MethylSeekRGR")`
- [ ] `PartitionedMethylome`
- [x] `partitionMethylome`

# Example script

To be adapted for processing all methylomes.
```{r, eval = FALSE}
# TODO: Investigate "chr.sel" argument
library("BSgenome.Hsapiens.UCSC.hg18")
seq_lengths <- seqlengths(Hsapiens)
x <- readMethylome(system.file("extdata", "Lister2009_imr90_hg18_chr22.tab", 
                               package = "MethylSeekR"), seq_lengths)
x <- MethPat(SimpleList(M = matrix(as.integer(x$M), 
                                   dimnames = list(NULL, "IMR90")), 
                        U = matrix(as.integer(x$T - x$M), 
                                   dimnames = list(NULL, "IMR90"))), 
             MTuples(GTuples(seqnames(x), tuples = as.matrix(start(x)), 
                             strand(x), seqinfo = seqinfo(x)),
                     MethInfo("CG"))
             )
msrgr <- as(x, "MethylSeekRGR")[[1]]

# TODO: Use MethylationTuples::filterVariants
snps <- readSNPTable(system.file("extdata", "SNVs_hg18_chr22.tab", 
                                 package = "MethylSeekR"), 
                     seq_lengths)

msrgr <- removeSNPs(msrgr, snps)
# TODO: Save plot as PDF
plotAlphaDistributionOneChr(m = msrgr, chr.sel = "chr22", num.cores = 1)
# TODO: Save plot as PDF
pmrs <- segmentPMDs(m = msrgr, chr.sel = "chr22", seqLengths = seq_lengths, 
                    num.cores = 1)
plotAlphaDistributionOneChr(m = subsetByOverlaps(
  msrgr, pmrs[values(pmrs)$type == "notPMD"]), chr.sel = "chr22", num.cores = 1)
# plotPMDSegmentation(m = msrgr, segs = pmrs)

# TODO: Update with path to appropriate CGI definition
cgi_file <- "~/Downloads/model-based-cpg-islands-hg18.txt"
cgi <- read.table(cgi_file, header = TRUE, as.is = TRUE)
cgi <- sort(GRanges(cgi$chr, IRanges(cgi$start, cgi$end), seqinfo = seqinfo(msrgr)))
cgi <- trim(resize(cgi, 5000, fix = "center"))

# TODO: Save plot as PDF
# TODO: If sample has no PMRs then the "PMDs" argument should be omitted.
fdrs <- calculateFDRs(m = msrgr, CGIs = cgi, PMDs = pmrs, num.cores = 1)
fdr_cutoff <- 5 
methylation_cutoff <- 0.5
minimum_number_cpgs <- as.integer(
  names(fdrs$FDRs[as.character(methylation_cutoff), ]
        [fdrs$FDRs[as.character(methylation_cutoff), ] < fdr_cutoff])[1])

# TODO: Update "myGenomeSeq" parameter according to sample.
# TODO: Save plot as PDF
# TODO: If sample has no PMRs then the "PMDs" argument should be omitted.
umrs_lmrs <- segmentUMRsLMRs(m = msrgr, meth.cutoff = methylation_cutoff,
                             nCpG.cutoff = minimum_number_cpgs, PMDs = pmrs, 
                             num.cores = 1, myGenomeSeq = Hsapiens, 
                             seqLengths = seq_lengths)
# plotFinalSegmentation(m = m, segs = umrs_lmrs, PMDs = pmrs, 
#                       meth.cutoff = methylation_cutoff)

pm <- partitionMethylome(umrs_lmrs = umrs_lmrs, pmrs = pmrs)
```

# TODO for tomorrow (06/02/2015)

- [ ] Create a list of `methsim::MethylSeekRGR` objects for the EPISCOPE, Lister, Seisenberger and Ziller datasets.
- [ ] Process each with `MethylSeekR` to create a partitioned methylome for each sample.
- [ ] Write `estModelParams(pm, 1-tuples or methLevel(), 2-tuples or cometh, higher-order tuples)`. For each type of region it should return the distribution of beta-values, co-methylation and haplotype frequencies.
  - Should return `params`, an S4 class with the necessary simulation parameters.
- [ ] Write `simulate(params, nsim, seed, ...)` to simulate a methylome with the given parameters.
- [ ] Write `addDMRs(params)` to return a modified version of `params` with DMRs.
