### =========================================================================
### Sampling utility functions. These functions are not exported.
### -------------------------------------------------------------------------

#' Sample MethLevelDT
#'
#' Sample with replacement from meth_level_dt, stratified by region_type, such
#' that each region is assigned an (average) methylation level.
#' @keywords internal
.sampleMethLevelDT <- function(meth_level_dt, region_type) {
  region_type_levels <- levels(region_type)
  meth_level <- rep(NA_real_, length(region_type))
  for (level in region_type_levels) {
    mli <- which(meth_level_dt[, type] == level)
    ml <- meth_level_dt[mli, ]
    rti <- which(region_type == level)
    n <- length(rti)
    meth_level[rti] <- ml[sample(nrow(ml),
                                   n,
                                   replace = TRUE,
                                   prob = ml[, N]), beta]
  }
  meth_level
}

#' Sample from co-methylation distribution.
#'
#' Sample with replacement from cometh_dt, stratified by region_type, such that
#' methylation loci 2-tuple is assigned a level of within-fragment
#' co-methylation (on the log odds-ratio scale i.e., lor). If there are fewer
#' than min_n observations for that IPD-type combination then the lor is
#' simulated from a Gaussian distribution, with mean given by mean_fn and
#' standard deviation given by sd_fn.
#' @param two_tuples a
#' \code{MethylationTuples::\link[MethylationTuples]{Mtuples}} containing all
#' two-tuples of methylation loci in the genome. Typically generated by
#' \code{MethylationTuples::\link[MethylationTuples]{findMTuples}}.
#' @param partitioned_methylome a \code{\link{PartitionedMethylome}} object.
#' @param min_n the minimum number of observations on a IPD-type combination in
#' order to sample from the empirical distribution as opposed to sampling from
#' the Gaussian(mean_fun(ipd, type), sd_fun(ipd, type)) distribution.
#' @param mean_fun a function specifying the mean LOR for a given IPD-type
#' combination.
#' @param sd_fun a function specifying the standard deviation of the LOR for a
#' given IPD-type combination.
#'
#' @return A vector of log odds-ratios (LOR), one for each 2-tuple.
#' @keywords internal
.sampleComethDT <- function(two_tuples, cometh_dt, partitioned_methylome,
                            min_n = 100L, mean_fun = function(ipd, type) 0,
                            sd_fun = function(ipd, type) 1) {

  # If a 2-tuple isn't within a region, then the region_type is (somewhat
  # arbitrarily) defined by the region for the first methylation loci in the
  # tuple.
  within_ol <- findOverlaps(two_tuples, partitioned_methylome, type = "within")
  not_within <- which(!seq_len(queryLength(within_ol)) %in%
                        queryHits(within_ol))
  end_ol <- findOverlaps(two_tuples[not_within], partitioned_methylome,
                         type = "any", select = "first")
  mcols(two_tuples)$regionType <-
    regionType(partitioned_methylome)[c(subjectHits(within_ol), end_ol)]
  region_type <- regionType(partitioned_methylome)
  region_type_levels <- levels(region_type)
  lor <- rep(NA_real_, length(two_tuples))

  two_tuples_dt <- data.table(IPD = as.vector(IPD(two_tuples)),
                              type = regionType(partitioned_methylome)[
                                c(subjectHits(within_ol), end_ol)])
  # Tabulate the number of occurences of each IPD-type combination (n).
  two_tuples_reduced_dt <- two_tuples_dt[, list(n = .N), by = list(IPD, type)]
  setkey(two_tuples_reduced_dt, IPD, type)
  setkey(cometh_dt, IPD, type)

  lor_list <- lapply(seq_len(nrow(two_tuples_reduced_dt)),
                     function(i, two_tuples_reduced_dt, cometh_dt, min_n) {
    # Create a table with all the co-methylation data for that IPD-type
    # combination
    x <- cometh_dt[two_tuples_reduced_dt[i, ]]
    if (isTRUE(x[, sum(N)] > min_n)) {
      x[, sample(x = statistic, size = n, replace = TRUE, prob = N)]
    } else {
      # UP TO HERE: Enable loess-Gaussian simulated data
      rnorm(n = two_tuples_reduced_dt[i, n],
            mean = mean_fun(two_tuples_reduced_dt[i, IPD],
                            two_tuples_reduced_dt[i, type]),
            sd = sd_fun(two_tuples_reduced_dt[i, IPD],
                        two_tuples_reduced_dt[i, type]))
    }
  }, two_tuples_reduced_dt, cometh_dt, min_n)
  # UP TO HERE: Extract values from lor_list and insert them appropriately for
  # the two_tuples based on IPD-type combination.
  two_tuples_dt[, idx := .I]
  setkey(two_tuples_dt, IPD, type)
  two_tuples_dt[, lor := unlist(x = lor_list, recursive = TRUE,
                                use.names = FALSE)]
  setkey(two_tuples_dt, idx)
  two_tuples_dt[, lor]
}

# TODO: A general framework for creating mean_fn and sd_fn (currently commented
# out).
# Set the mean and sd of lors on which we have no data.
# __This is very arbitrary because we have no data__.
# lapply(region_type_levels, function(rt, cometh_dt) {
#   x <- cometh_dt[type == rt, ]
#   mean_dt <- x[, list(mean = mean(rep(statistic, N), na.rm = TRUE)), by = IPD]
#   sd_dt <- x[, list(sd = sd(rep(statistic, N), na.rm = TRUE)), by = IPD]
#   # TODO: Should return a mean_fun and a sd_fun, e.g., based on a loess or
#   # spline fit. The challenge is in extrapolating to arbitrary IPDs, given that
#   # we only observe a very limited range of IPDs.m
# })

#' Sample PatternFreqsDT
#'
#' Sample with replacement from pattern_freqs_dt, stratified by region_type,
#' such that each region is assigned a vector of haplotype frequencies.
#' @keywords internal
.samplePatternFreqsDT <- function(pattern_freqs_dt, region_type) {
  h <- grep("^h", colnames(pattern_freqs_dt), value = TRUE)
  region_type_levels <- levels(region_type)
  H <- matrix(NA_real_, ncol = length(h), nrow = length(region_type))
  for (level in region_type_levels) {
    pfi <- which(pattern_freqs_dt[, type] == level)
    pf <- pattern_freqs_dt[pfi, ]
    rti <- which(region_type == level)
    n <- length(rti)
    H[rti, ] <- as.matrix(
      pf[sample(nrow(pf),
                n,
                replace = TRUE,
                prob = pf[, N])][, h, with = FALSE])
  }
  H
}

#' Simulate Z
#'
#' Simulate a single methylome (Z).
#' @keywords internal
.simulateZ <- function(beta_by_region, lor_by_pair, one_tuples, two_tuples) {
  # TODO: Leave beta_by_region as an Rle (will require changes to
  # .simulateZOneChr()).
  # Map .simulateZOneChr() across all chromosomes
  Z_list <- Map(.simulateZOneChr,
                split(as.vector(beta_by_region), seqnames(one_tuples)),
                split(lor_by_pair, seqnames(two_tuples)))
  unlist(Z_list, use.names = FALSE)
}

