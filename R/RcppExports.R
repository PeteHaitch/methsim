# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

f <- function(psi, b1, b2) {
    .Call('methsim_f', PACKAGE = 'methsim', psi, b1, b2)
}

f2 <- function(psi, b1, b2) {
    .Call('methsim_f2', PACKAGE = 'methsim', psi, b1, b2)
}

f3 <- function(psi, b1, b2) {
    .Call('methsim_f3', PACKAGE = 'methsim', psi, b1, b2)
}

f4 <- function(psi, b1, b2) {
    .Call('methsim_f4', PACKAGE = 'methsim', psi, b1, b2)
}

f5 <- function(psi, b1, b2) {
    .Call('methsim_f5', PACKAGE = 'methsim', psi, b1, b2)
}

f6 <- function(psi, b1, b2) {
    .Call('methsim_f6', PACKAGE = 'methsim', psi, b1, b2)
}

g <- function(psi, b1, b2) {
    .Call('methsim_g', PACKAGE = 'methsim', psi, b1, b2)
}

g2 <- function(psi, b1, b2) {
    .Call('methsim_g2', PACKAGE = 'methsim', psi, b1, b2)
}

g3 <- function(psi, b1, b2) {
    .Call('methsim_g3', PACKAGE = 'methsim', psi, b1, b2)
}

g4 <- function(psi, b1, b2) {
    .Call('methsim_g4', PACKAGE = 'methsim', psi, b1, b2)
}

g5 <- function(psi, b1, b2) {
    .Call('methsim_g5', PACKAGE = 'methsim', psi, b1, b2)
}

g6 <- function(psi, b1, b2) {
    .Call('methsim_g6', PACKAGE = 'methsim', psi, b1, b2)
}

.simulateZ3 <- function(beta_by_region, lor_by_pair, seqnames_one_tuples, u) {
    .Call('methsim_simulateZ3', PACKAGE = 'methsim', beta_by_region, lor_by_pair, seqnames_one_tuples, u)
}

ipf <- function(seed, row_margins, col_margins, iter = 1000L, tol = 1e-10) {
    .Call('methsim_ipf', PACKAGE = 'methsim', seed, row_margins, col_margins, iter, tol)
}

#' Sample W.
#'
#' Sample a column of W for each row of W with the probability of sampling
#' column j for row i given by W[i, j].
#'
#' @param W a numeric matrix where W[i, j] is the probability of sampling
#' column j for row i, i.e., rowMeans(W) == 1.
#'
#' @keywords internal
#'
#' @return an integer vector of length equal to nrow(W), where each element is
#' the column sampled for that row.
.sampleW <- function(W) {
    .Call('methsim_sampleW', PACKAGE = 'methsim', W)
}

#' Sample Z.
#'
#' Simulate sequencing reads by sampling a subset of rows from a given column
#' of W for each read.
#'
#' @param Z an integer matrix where Z[i, j] is the methylation state of the
#' i-th methylation locus on the j-th pseud-haplotype.
#' @param sampled_W an integer vector of length equal to the number of reads.
#' Each element is the pseudo-haplotype from which each read is to be sampled,
#' i.e., Z[, j].
#' @param fh an integer vector of length equal to the number of reads. Each
#' element is the position of the first methylation loci ("first hit") from
#' which read is to be sampled, i.e., Z[i, ].
#' @param cqh an integer vector of length equal to the number of reads. Each
#' element is the number of methylation loci that each read overlaps.
#'
#' @keywords internal
#'
#' @return a list of length equal to the number of simulated reads. Each list
#' element is the sequenced/sampled methylation state for that read.
.sampleZ <- function(Z, sampled_W, fh, cqh) {
    .Call('methsim_sampleZ', PACKAGE = 'methsim', Z, sampled_W, fh, cqh)
}

#' Simulate sequencing errors.
#'
#' Simulate sequencing errors by modifying \code{z} in place.
#'
#' @param z an integer vector of sampled methylation states.
#' @param u an integer vector with the same length as \code{z} of random
#' variables distributed as Uniform(0, 1).
#' @param errorRate the (combined) probability of an "error", where an error
#' may be sequencing error or error in the bisulfite-conversion process.
#'
#' @note \strong{WARNING}: \code{z} is modified \strong{in place}.
#'
#' @return \code{NULL}. \code{z} is modified \strong{in place}.
#'
#' @keywords internal
.simErrorInPlace <- function(z, u, errorRate) {
    invisible(.Call('methsim_simErrorInPlace', PACKAGE = 'methsim', z, u, errorRate))
}

#' Simulate a single "haplotype" of a methylome (Z).
#'
#' @param beta_by_region the beta-value (average methylation level) for each
#' methylation locus in the genome.
#' @param lor_by_pair the within-fragment co-methylation between each pair of
#' methylation loci in the genome. Should be log odds-ratios using base-2
#' logarithms. The length of this should be equal to the number of methylation
#' loci in the genome minus the number of chromosomes (seqnames).
#' @param seqnames_one_tuples the chromosome (seqname) of each methylation
#' locus in the genome, i.e., \code{seqnames(one_tuples)}.
#' @param u a vector of Uniform(0, 1) random variables used in choosing the
#' next state of the process. Must have same length as \code{beta_by_region}.
#'
#' @note Random number generation is performed outside of this function (at
#' the R level in a single thread) in order to simplify this function. If
#' the vector of Uniform(0, 1) random variables ('u') is to be simulated
#' within this function at the C++ level then great care must be taken,
#' especially if this function is subsequently called in parallel.
#'
#' @return an integer vector of simulated methylation states for each
#' methylation locus in the genome; 0 = unmethylated and 1 = methylated.
.simulateZ2 <- function(beta_by_region, lor_by_pair, seqnames_one_tuples, u) {
    .Call('methsim_simulateZ2', PACKAGE = 'methsim', beta_by_region, lor_by_pair, seqnames_one_tuples, u)
}

#' Simulate a single "haplotype" of a methylome (Z).
#'
#' @param beta_by_region the beta-value (average methylation level) for each
#' methylation locus in the genome.
#' @param lor_by_pair the within-fragment co-methylation between each pair of
#' methylation loci in the genome. Should be log odds-ratios using base-2
#' logarithms. The length of this should be equal to the number of methylation
#' loci in the genome minus the number of chromosomes (seqnames).
#' @param seqnames_one_tuples the chromosome (seqname) of each methylation
#' locus in the genome, i.e., \code{seqnames(one_tuples)}.
#' @param u a vector of Uniform(0, 1) random variables used in choosing the
#' next state of the process. Must have same length as \code{beta_by_region}.
#'
#' @note Random number generation is performed outside of this function (at
#' the R level in a single thread) in order to simplify this function. If
#' the vector of Uniform(0, 1) random variables ('u') is to be simulated
#' within this function at the C++ level then great care must be taken,
#' especially if this function is subsequently called in parallel.
#'
#' @return an integer vector of simulated methylation states for each
#' methylation locus in the genome; 0 = unmethylated and 1 = methylated.
.simulateZ <- function(beta_by_region, lor_by_pair, seqnames_one_tuples, u) {
    .Call('methsim_simulateZ', PACKAGE = 'methsim', beta_by_region, lor_by_pair, seqnames_one_tuples, u)
}

#' Tabulate methylation patterns.
#'
#' Tabulate methylation patterns of a given \code{size} from the elements of
#' the \code{z} slot of a \code{\link{SimulatedBS}} object.
#'
#' @param readID an integer vector of read IDs; the \code{readID} column of
#' an element of the \code{z} slot of a \code{\link{SimulatedBS}} object.
#' @param z an integer vector of methylation states; the \code{z} column of
#' an element of the \code{z} slot of a \code{\link{SimulatedBS}} object.
#' @param pos an integer vector of the positions of methylation loci sequenced
#' by each read; the \code{pos} column of an element of the \code{z} slots of
#' a \code{\link{SimulatedBS}} object.
#' @param size an integer greater than 1 specifying the size of the m-tuples
#' to be created.
#'
#' @return A list of tabulated methylation patterns. The name of each list
#' element is a comma-separated string of positions for that m-tuple and the
#' value of each element is a vector of associated counts (the order of this
#' vector is identical to that given by
#' \code{MethylationTuples:::\link[MethylationTuples]{.makeMethPatNames}}).
#'
#' @note \strong{WARNING}: Only adjacent m-tuples, with respect to the
#' sequenced methylation loci, are created. This means that (A) the list will
#' contain unobserved m-tuples (i.e., those with all counts set to zero) and
#' (B) that it will be possibly with paired-end reads to create m-tuples with
#' NIC > 0.
#' \strong{WARNING}: The special case where \code{size} = 1 is handled
#' separately by tabulating with the \code{data.table} package.
#'
#' @keywords internal
#'
.tabulatez <- function(readID, z, pos, size) {
    .Call('methsim_tabulatez', PACKAGE = 'methsim', readID, z, pos, size)
}

# Register entry points for exported C++ functions
methods::setLoadAction(function(ns) {
    .Call('methsim_RcppExport_registerCCallable', PACKAGE = 'methsim')
})
